<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Ja: Beam Programming Guide</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="../github.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script src="../prism.js"></script>
</head>
<body>
<p><a href="../index.html">topへ</a></p>
<h1 id="overview">Overview</h1>
<h2 id="beamによるデータ処理"><span class="head">Beamによるデータ処理</span></h2>
<p>Apache Beamでは大規模なデータ処理をわりと簡単に (?) 実装できます。並列化の実装を全くせずに、パイプラインにおける処理が並列に捌かれます。たとえばDataflowで複数のVMに処理をさせるときに、コードの変更であったり並列処理の仕掛けを作ってやる必要がありません。</p>
<p>またストリーミング処理をバッチ処理とほぼ同じ感じで実装可能です。ストリーミング処理で気にするのは、どのタイミングで処理を発火させるのか、くらいですかね。</p>
<p>Beamを使ったプログラミング・実行の際に、ユーザが決めるべきことは</p>
<ul>
<li>プログラミング時
<ul>
<li>実行時オプション<br />
プログラムの実行時にパラメータをとれますが、当然定義は必要です</li>
<li>Input / Output<br />
けっこうな入出力先がサポートされてます<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a><br />
</li>
<li>行う変換処理</li>
</ul></li>
<li>実行時
<ul>
<li>実行環境<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></li>
<li>実行時オプション</li>
</ul></li>
</ul>
<h2 id="beamで現れる概念"><span class="head">Beamで現れる概念</span></h2>
<p>Beamには特有の用語がいくつかあります。</p>
<ul>
<li>
<code>Pipeline</code>
</li>
<p>データ処理の最初から最後まで。</p>
<li>
<code>PCollection</code>
</li>
処理を行うデータの集まりで、Beamではこのデータの塊に対して処理を加えていきます。<br />
原則、<code>PCollection</code>の中の要素は等価だと思うべきです。
<pre><code>苗字の集まり。
[
  "佐藤","鈴木","田中", ...
]  
文字列の集まり。佐藤さんの情報たち、と捉えない方が良いです。
[
  "佐藤","32歳","172cm", ...
]
</code></pre>
<p>バッチ処理とストリーミング処理の違いは、データの終わりの有無です。前述の通りBeamではどちらもほぼ同じように扱えます。ただ全く同じわけではないので、それぞれ名前が付いてます。</p>
<ul>
<li>
Bounded
</li>
データに終わりがある。(e.g. ファイル読み込み)
<li>
Unbound
</li>
データに終わりがない。(e.g. Twitterとか)
</ul>
<p>通常は外部ソースからの読み込みですが、unit testや練習のために、コード内でデータを作ることもできます（BeamではJUnitが使えます）。</p>
<li>
<code>PTransform</code>
</li>
<p>Pipelineにおける各処理のステップです。Beam SDKで提供される<code>PTransform</code>はたくさんありますが、ユーザ定義の変換処理を適用可能です。 <code>PCollection</code>をinputとして受け取り、処理を加えた<code>PCollection</code>をoutputとして返す。</p>
<li>
I/O Transform
</li>
入出力を行う<code>PTransform</code>なのですが、<code>Pipeline</code>の始めと終わりになります。 Beamでは様々な入出力先をサポートしてます。Datastore, BigQuery, Cloud Storage, Amazon S3, … etc.
</ul>
<blockquote>
<h4 id="io-transformについてメモ">I/O Transformについてメモ</h4>
<p><code>pipeline</code>の途中の<code>PTransform</code>では<code>PCollection</code>を受け取り、変換処理を行います。ですがBeam SDKによるデータの読み込みでは、<code>PCollection</code>を受け取りません。<br />
なのでBeamを使って、GCSにアップされたファイルを読み込み、そのファイルに書かれた別のファイルたちを読み込みたい、みたいな処理は難しかったりします。<br />
入出力を可変にするならば、<code>pipeline</code>の実行時オプションとして指定するのが吉です。</p>
</blockquote>
<h2 id="codingの流れ"><span class="head">Codingの流れ</span></h2>
<h3 id="pipelineオブジェクトの作成">1. Pipelineオブジェクトの作成</h3>
<p>実行時に受け付けるオプション（入出力先とか）を定義した後、<code>Pipeline</code>オブジェクトを作ります。</p>
<h3 id="pcollectionの作成">2. PCollectionの作成</h3>
<p>I/O Transformを使って外部から読むか、コード内で適当に初期値を作るか（主に）のどちらか。Pipelineのデータソースは複数指定可能で、<code>Pipeline</code>オブジェクトに関連づけられます。</p>
<h3 id="ptransformの適用">3. PTransformの適用</h3>
<p><code>PCollection</code>に処理を加えていきます。できることを大雑把に触れておくと、</p>
<ul>
<li>データの変換、整形</li>
<li>フィルター</li>
<li>グループ化（国籍で分ける、みたいな）</li>
<li>解析（平均値の計算とか）</li>
<li><code>PCollection</code>内の要素を調べる</li>
</ul>
<p>とかです。</p>
<h3 id="iotransformで外部への出力">4. I/OTransformで、外部への出力</h3>
<p>ローカルファイルとか、BigQueryのtableにデータを出力します。</p>
<h3 id="pipelineの実行">5. Pipelineの実行</h3>
<p>一連の処理の流れを作り終えたら、Pipelineを実行するためのメソッドの呼び出します。処理の一連の流れはgraphっていう。こんな感じでgraphに分岐があってもokです。</p>
<blockquote>
<p><img src="./figs/monitoring-side-input-write.png" width="800"><br />
<a href="https://cloud.google.com/dataflow/docs/guides/using-monitoring-intf#side_input_metrics">https://cloud.google.com/dataflow/docs/guides/using-monitoring-intf#side_input_metrics</a></p>
</blockquote>
<p>また、Pipeline処理の完了後に何か処理を行うこともできます。</p>
<p>Beamの動作詳細としては、</p>
<ol type="1">
<li>Pipeline graphの作成（↑の写真みたいな）<br />
処理の依存関係をみたりしてるのかと思ってます。<br />
</li>
<li>作成されたgraphの実行</li>
</ol>
<p>BeamでのPipeline処理は並行分散処理なので、捌かれる要素の順番を指定するのは原則不可です。また、場合によっては複数回同じ処理が実行されたりします。</p>
<blockquote>
<h4 id="memo">memo</h4>
<p>Cloud SQL → Cloud Spannerのデータ移行をDataflowで行なった際、同一レコードが複数回書き込まれる現象に遭遇しました。</p>
</blockquote>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>https://beam.apache.org/documentation/io/built-in/<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>https://beam.apache.org/documentation/runners/capability-matrix<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
